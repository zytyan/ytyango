// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query_gemini.sql

package q

import (
	"context"
	"database/sql"
	"time"

	"go.uber.org/zap"
)

const addGeminiMessage = `-- name: AddGeminiMessage :exec
INSERT INTO gemini_contents (session_id,
                             chat_id,
                             msg_id,
                             role,
                             sent_time,
                             username,
                             msg_type,
                             reply_to_msg_id,
                             text,
                             blob,
                             mime_type)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type AddGeminiMessageParams struct {
	SessionID    int64          `json:"session_id"`
	ChatID       int64          `json:"chat_id"`
	MsgID        int64          `json:"msg_id"`
	Role         string         `json:"role"`
	SentTime     UnixTime       `json:"sent_time"`
	Username     string         `json:"username"`
	MsgType      string         `json:"msg_type"`
	ReplyToMsgID sql.NullInt64  `json:"reply_to_msg_id"`
	Text         sql.NullString `json:"text"`
	Blob         []byte         `json:"blob"`
	MimeType     sql.NullString `json:"mime_type"`
}

func (q *Queries) AddGeminiMessage(ctx context.Context, arg AddGeminiMessageParams) error {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 6)
		start = time.Now()
		logFields = append(logFields,
			zap.Dict("fields",
				zap.Int64("session_id", arg.SessionID),
				zap.Int64("chat_id", arg.ChatID),
				zap.Int64("msg_id", arg.MsgID),
				zap.String("role", arg.Role),
				arg.SentTime.ZapObject("sent_time"),
				zap.String("username", arg.Username),
				zap.String("msg_type", arg.MsgType),
				zapNullInt64("reply_to_msg_id", arg.ReplyToMsgID),
				zapNullString("text", arg.Text),
				zap.ByteString("blob", arg.Blob),
				zapNullString("mime_type", arg.MimeType),
			),
		)
	}
	_, err := q.exec(ctx, q.addGeminiMessageStmt, addGeminiMessage,
		arg.SessionID,
		arg.ChatID,
		arg.MsgID,
		arg.Role,
		arg.SentTime,
		arg.Username,
		arg.MsgType,
		arg.ReplyToMsgID,
		arg.Text,
		arg.Blob,
		arg.MimeType,
	)
	q.logQuery(addGeminiMessage, logFields, err, start)
	return err
}

const createNewGeminiSession = `-- name: CreateNewGeminiSession :one

INSERT INTO gemini_sessions (chat_id, chat_name, chat_type)
VALUES (?, ?, ?)
RETURNING id, chat_id, chat_name, chat_type
`

// encoding: utf-8
func (q *Queries) CreateNewGeminiSession(ctx context.Context, chatID int64, chatName string, chatType string) (GeminiSession, error) {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 6)
		start = time.Now()
		logFields = append(logFields,
			zap.Dict("fields",
				zap.Int64("chat_id", chatID),
				zap.String("chat_name", chatName),
				zap.String("chat_type", chatType),
			),
		)
	}
	row := q.queryRow(ctx, q.createNewGeminiSessionStmt, createNewGeminiSession, chatID, chatName, chatType)
	var i GeminiSession
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.ChatName,
		&i.ChatType,
	)
	q.logQuery(createNewGeminiSession, logFields, err, start)
	return i, err
}

const getSessionById = `-- name: GetSessionById :one
SELECT id, chat_id, chat_name, chat_type
FROM gemini_sessions
WHERE id = ?
`

func (q *Queries) GetSessionById(ctx context.Context, id int64) (GeminiSession, error) {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 6)
		start = time.Now()
		logFields = append(logFields,
			zap.Dict("fields",
				zap.Int64("id", id),
			),
		)
	}
	row := q.queryRow(ctx, q.getSessionByIdStmt, getSessionById, id)
	var i GeminiSession
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.ChatName,
		&i.ChatType,
	)
	q.logQuery(getSessionById, logFields, err, start)
	return i, err
}

const getSessionIdByMessage = `-- name: GetSessionIdByMessage :one
SELECT gemini_contents.session_id
FROM gemini_contents
WHERE chat_id = ?
  AND msg_id = ?
`

func (q *Queries) GetSessionIdByMessage(ctx context.Context, chatID int64, msgID int64) (int64, error) {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 6)
		start = time.Now()
		logFields = append(logFields,
			zap.Dict("fields",
				zap.Int64("chat_id", chatID),
				zap.Int64("msg_id", msgID),
			),
		)
	}
	row := q.queryRow(ctx, q.getSessionIdByMessageStmt, getSessionIdByMessage, chatID, msgID)
	var session_id int64
	err := row.Scan(&session_id)
	q.logQuery(getSessionIdByMessage, logFields, err, start)
	return session_id, err
}

const getAllMsgInSessionReversed = `-- name: getAllMsgInSessionReversed :many
SELECT session_id, chat_id, msg_id, role, sent_time, username, msg_type, reply_to_msg_id, text, blob, mime_type
FROM gemini_contents
WHERE session_id = ?
ORDER BY msg_id DESC
LIMIT ?
`

func (q *Queries) getAllMsgInSessionReversed(ctx context.Context, sessionID int64, limit int64) ([]GeminiContent, error) {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 6)
		start = time.Now()
		logFields = append(logFields,
			zap.Dict("fields",
				zap.Int64("session_id", sessionID),
				zap.Int64("limit", limit),
			),
		)
	}
	rows, err := q.query(ctx, q.getAllMsgInSessionReversedStmt, getAllMsgInSessionReversed, sessionID, limit)
	defer func() {
		q.logQuery(getAllMsgInSessionReversed, logFields, err, start)
	}()
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GeminiContent
	for rows.Next() {
		var i GeminiContent
		if err = rows.Scan(
			&i.SessionID,
			&i.ChatID,
			&i.MsgID,
			&i.Role,
			&i.SentTime,
			&i.Username,
			&i.MsgType,
			&i.ReplyToMsgID,
			&i.Text,
			&i.Blob,
			&i.MimeType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err = rows.Close(); err != nil {
		return nil, err
	}
	if err = rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

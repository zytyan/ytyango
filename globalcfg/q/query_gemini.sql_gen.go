// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query_gemini.sql

package q

import (
	"context"
	"database/sql"
	"time"

	"go.uber.org/zap"
)

const addGeminiMessage = `-- name: AddGeminiMessage :exec
INSERT INTO gemini_contents (session_id,
                             chat_id,
                             msg_id,
                             role,
                             sent_time,
                             username,
                             msg_type,
                             reply_to_msg_id,
                             text,
                             blob,
                             mime_type,
                             quote_part,
                             thought_signature)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type AddGeminiMessageParams struct {
	SessionID        int64          `json:"session_id"`
	ChatID           int64          `json:"chat_id"`
	MsgID            int64          `json:"msg_id"`
	Role             string         `json:"role"`
	SentTime         UnixTime       `json:"sent_time"`
	Username         string         `json:"username"`
	MsgType          string         `json:"msg_type"`
	ReplyToMsgID     sql.NullInt64  `json:"reply_to_msg_id"`
	Text             sql.NullString `json:"text"`
	Blob             []byte         `json:"blob"`
	MimeType         sql.NullString `json:"mime_type"`
	QuotePart        sql.NullString `json:"quote_part"`
	ThoughtSignature sql.NullString `json:"thought_signature"`
}

func (q *Queries) AddGeminiMessage(ctx context.Context, arg AddGeminiMessageParams) error {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 8)
		start = time.Now()
		if q.LogArgument {
			logFields = append(logFields,
				zap.Dict("fields",
					zap.Int64("session_id", arg.SessionID),
					zap.Int64("chat_id", arg.ChatID),
					zap.Int64("msg_id", arg.MsgID),
					zap.String("role", arg.Role),
					arg.SentTime.ZapObject("sent_time"),
					zap.String("username", arg.Username),
					zap.String("msg_type", arg.MsgType),
					zapNullInt64("reply_to_msg_id", arg.ReplyToMsgID),
					zapNullString("text", arg.Text),
					zap.ByteString("blob", arg.Blob),
					zapNullString("mime_type", arg.MimeType),
					zapNullString("quote_part", arg.QuotePart),
					zapNullString("thought_signature", arg.ThoughtSignature),
				),
			)
		}
	}
	_, err := q.exec(ctx, q.addGeminiMessageStmt, addGeminiMessage,
		arg.SessionID,
		arg.ChatID,
		arg.MsgID,
		arg.Role,
		arg.SentTime,
		arg.Username,
		arg.MsgType,
		arg.ReplyToMsgID,
		arg.Text,
		arg.Blob,
		arg.MimeType,
		arg.QuotePart,
		arg.ThoughtSignature,
	)
	q.logQuery(addGeminiMessage, "AddGeminiMessage", logFields, err, start)
	return err
}

const createNewGeminiSession = `-- name: CreateNewGeminiSession :one

INSERT INTO gemini_sessions (chat_id, chat_name, chat_type)
VALUES (?, ?, ?)
RETURNING id, chat_id, chat_name, chat_type
`

// encoding: utf-8
func (q *Queries) CreateNewGeminiSession(ctx context.Context, chatID int64, chatName string, chatType string) (GeminiSession, error) {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 8)
		start = time.Now()
		if q.LogArgument {
			logFields = append(logFields,
				zap.Dict("fields",
					zap.Int64("chat_id", chatID),
					zap.String("chat_name", chatName),
					zap.String("chat_type", chatType),
				),
			)
		}
	}
	row := q.queryRow(ctx, q.createNewGeminiSessionStmt, createNewGeminiSession, chatID, chatName, chatType)
	var i GeminiSession
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.ChatName,
		&i.ChatType,
	)
	q.logQuery(createNewGeminiSession, "CreateNewGeminiSession", logFields, err, start)
	return i, err
}

const createOrUpdateGeminiSystemPrompt = `-- name: CreateOrUpdateGeminiSystemPrompt :exec
INSERT INTO gemini_system_prompt (chat_id, prompt)
VALUES (?, ?)
ON CONFLICT DO UPDATE SET prompt=excluded.prompt
`

func (q *Queries) CreateOrUpdateGeminiSystemPrompt(ctx context.Context, chatID int64, prompt string) error {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 8)
		start = time.Now()
		if q.LogArgument {
			logFields = append(logFields,
				zap.Dict("fields",
					zap.Int64("chat_id", chatID),
					zap.String("prompt", prompt),
				),
			)
		}
	}
	_, err := q.exec(ctx, q.createOrUpdateGeminiSystemPromptStmt, createOrUpdateGeminiSystemPrompt, chatID, prompt)
	q.logQuery(createOrUpdateGeminiSystemPrompt, "CreateOrUpdateGeminiSystemPrompt", logFields, err, start)
	return err
}

const getGeminiSystemPrompt = `-- name: GetGeminiSystemPrompt :one
SELECT prompt
FROM gemini_system_prompt
WHERE chat_id = ?
`

func (q *Queries) GetGeminiSystemPrompt(ctx context.Context, chatID int64) (string, error) {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 8)
		start = time.Now()
		if q.LogArgument {
			logFields = append(logFields,
				zap.Dict("fields",
					zap.Int64("chat_id", chatID),
				),
			)
		}
	}
	row := q.queryRow(ctx, q.getGeminiSystemPromptStmt, getGeminiSystemPrompt, chatID)
	var prompt string
	err := row.Scan(&prompt)
	q.logQuery(getGeminiSystemPrompt, "GetGeminiSystemPrompt", logFields, err, start)
	return prompt, err
}

const getSessionById = `-- name: GetSessionById :one
SELECT id, chat_id, chat_name, chat_type
FROM gemini_sessions
WHERE id = ?
`

func (q *Queries) GetSessionById(ctx context.Context, id int64) (GeminiSession, error) {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 8)
		start = time.Now()
		if q.LogArgument {
			logFields = append(logFields,
				zap.Dict("fields",
					zap.Int64("id", id),
				),
			)
		}
	}
	row := q.queryRow(ctx, q.getSessionByIdStmt, getSessionById, id)
	var i GeminiSession
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.ChatName,
		&i.ChatType,
	)
	q.logQuery(getSessionById, "GetSessionById", logFields, err, start)
	return i, err
}

const getSessionIdByMessage = `-- name: GetSessionIdByMessage :one
SELECT gemini_contents.session_id
FROM gemini_contents
WHERE chat_id = ?
  AND msg_id = ?
`

func (q *Queries) GetSessionIdByMessage(ctx context.Context, chatID int64, msgID int64) (int64, error) {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 8)
		start = time.Now()
		if q.LogArgument {
			logFields = append(logFields,
				zap.Dict("fields",
					zap.Int64("chat_id", chatID),
					zap.Int64("msg_id", msgID),
				),
			)
		}
	}
	row := q.queryRow(ctx, q.getSessionIdByMessageStmt, getSessionIdByMessage, chatID, msgID)
	var session_id int64
	err := row.Scan(&session_id)
	q.logQuery(getSessionIdByMessage, "GetSessionIdByMessage", logFields, err, start)
	return session_id, err
}

const getAllMsgInSessionReversed = `-- name: getAllMsgInSessionReversed :many
SELECT session_id, chat_id, msg_id, role, sent_time, username, msg_type, reply_to_msg_id, text, blob, mime_type, quote_part, thought_signature
FROM gemini_contents
WHERE session_id = ?
ORDER BY msg_id DESC
LIMIT ?
`

func (q *Queries) getAllMsgInSessionReversed(ctx context.Context, sessionID int64, limit int64) ([]GeminiContent, error) {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 8)
		start = time.Now()
		if q.LogArgument {
			logFields = append(logFields,
				zap.Dict("fields",
					zap.Int64("session_id", sessionID),
					zap.Int64("limit", limit),
				),
			)
		}
	}
	rows, err := q.query(ctx, q.getAllMsgInSessionReversedStmt, getAllMsgInSessionReversed, sessionID, limit)
	defer func() {
		q.logQuery(getAllMsgInSessionReversed, "getAllMsgInSessionReversed", logFields, err, start)
	}()
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GeminiContent
	for rows.Next() {
		var i GeminiContent
		if err = rows.Scan(
			&i.SessionID,
			&i.ChatID,
			&i.MsgID,
			&i.Role,
			&i.SentTime,
			&i.Username,
			&i.MsgType,
			&i.ReplyToMsgID,
			&i.Text,
			&i.Blob,
			&i.MimeType,
			&i.QuotePart,
			&i.ThoughtSignature,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err = rows.Close(); err != nil {
		return nil, err
	}
	if err = rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query_gemini.sql

package q

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addGeminiMessage = `-- name: AddGeminiMessage :exec
INSERT INTO gemini_contents (session_id,
                             chat_id,
                             msg_id,
                             role,
                             sent_time,
                             username,
                             msg_type,
                             reply_to_msg_id,
                             text,
                             blob,
                             mime_type,
                             quote_part,
                             thought_signature)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
`

type AddGeminiMessageParams struct {
	SessionID        int64              `json:"session_id"`
	ChatID           int64              `json:"chat_id"`
	MsgID            int64              `json:"msg_id"`
	Role             string             `json:"role"`
	SentTime         pgtype.Timestamptz `json:"sent_time"`
	Username         string             `json:"username"`
	MsgType          string             `json:"msg_type"`
	ReplyToMsgID     pgtype.Int8        `json:"reply_to_msg_id"`
	Text             pgtype.Text        `json:"text"`
	Blob             []byte             `json:"blob"`
	MimeType         pgtype.Text        `json:"mime_type"`
	QuotePart        pgtype.Text        `json:"quote_part"`
	ThoughtSignature pgtype.Text        `json:"thought_signature"`
}

func (q *Queries) AddGeminiMessage(ctx context.Context, arg AddGeminiMessageParams) error {
	_, err := q.db.Exec(ctx, addGeminiMessage,
		arg.SessionID,
		arg.ChatID,
		arg.MsgID,
		arg.Role,
		arg.SentTime,
		arg.Username,
		arg.MsgType,
		arg.ReplyToMsgID,
		arg.Text,
		arg.Blob,
		arg.MimeType,
		arg.QuotePart,
		arg.ThoughtSignature,
	)
	return err
}

const createNewGeminiSession = `-- name: CreateNewGeminiSession :one

INSERT INTO gemini_sessions (chat_id, chat_name, chat_type)
VALUES ($1, $2, $3)
RETURNING id, chat_id, chat_name, chat_type
`

// encoding: utf-8
func (q *Queries) CreateNewGeminiSession(ctx context.Context, chatID int64, chatName string, chatType string) (GeminiSession, error) {
	row := q.db.QueryRow(ctx, createNewGeminiSession, chatID, chatName, chatType)
	var i GeminiSession
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.ChatName,
		&i.ChatType,
	)
	return i, err
}

const getSessionById = `-- name: GetSessionById :one
SELECT id, chat_id, chat_name, chat_type
FROM gemini_sessions
WHERE id = $1
`

func (q *Queries) GetSessionById(ctx context.Context, id int64) (GeminiSession, error) {
	row := q.db.QueryRow(ctx, getSessionById, id)
	var i GeminiSession
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.ChatName,
		&i.ChatType,
	)
	return i, err
}

const getSessionIdByMessage = `-- name: GetSessionIdByMessage :one
SELECT gemini_contents.session_id
FROM gemini_contents
WHERE chat_id = $1
  AND msg_id = $2
`

func (q *Queries) GetSessionIdByMessage(ctx context.Context, chatID int64, msgID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getSessionIdByMessage, chatID, msgID)
	var session_id int64
	err := row.Scan(&session_id)
	return session_id, err
}

const getAllMsgInSessionReversed = `-- name: getAllMsgInSessionReversed :many
SELECT session_id, chat_id, msg_id, role, sent_time, username, msg_type, reply_to_msg_id, text, blob, mime_type, quote_part, thought_signature
FROM gemini_contents
WHERE session_id = $1
ORDER BY msg_id DESC
LIMIT $2
`

func (q *Queries) getAllMsgInSessionReversed(ctx context.Context, sessionID int64, limit int32) ([]GeminiContent, error) {
	rows, err := q.db.Query(ctx, getAllMsgInSessionReversed, sessionID, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GeminiContent
	for rows.Next() {
		var i GeminiContent
		if err := rows.Scan(
			&i.SessionID,
			&i.ChatID,
			&i.MsgID,
			&i.Role,
			&i.SentTime,
			&i.Username,
			&i.MsgType,
			&i.ReplyToMsgID,
			&i.Text,
			&i.Blob,
			&i.MimeType,
			&i.QuotePart,
			&i.ThoughtSignature,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

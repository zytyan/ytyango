// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query_chat.sql

package q

import (
	"context"
	"database/sql"
	"time"

	"go.uber.org/zap"
)

const createChatCfg = `-- name: CreateChatCfg :exec
INSERT INTO chat_cfg (id, web_id, auto_cvt_bili, auto_ocr, auto_calculate, auto_exchange, auto_check_adult,
                      save_messages, enable_coc, resp_nsfw_msg, timezone)
VALUES (?, ?, ?, ?, ?, ?,
        ?, ?, ?, ?, ?)
`

type CreateChatCfgParams struct {
	ID             int64         `json:"id"`
	WebID          sql.NullInt64 `json:"web_id"`
	AutoCvtBili    bool          `json:"auto_cvt_bili"`
	AutoOcr        bool          `json:"auto_ocr"`
	AutoCalculate  bool          `json:"auto_calculate"`
	AutoExchange   bool          `json:"auto_exchange"`
	AutoCheckAdult bool          `json:"auto_check_adult"`
	SaveMessages   bool          `json:"save_messages"`
	EnableCoc      bool          `json:"enable_coc"`
	RespNsfwMsg    bool          `json:"resp_nsfw_msg"`
	Timezone       int64         `json:"timezone"`
}

func (q *Queries) CreateChatCfg(ctx context.Context, arg CreateChatCfgParams) error {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 8)
		start = time.Now()
		if q.LogArgument {
			logFields = append(logFields,
				zap.Dict("fields",
					zap.Int64("id", arg.ID),
					zapNullInt64("web_id", arg.WebID),
					zap.Bool("auto_cvt_bili", arg.AutoCvtBili),
					zap.Bool("auto_ocr", arg.AutoOcr),
					zap.Bool("auto_calculate", arg.AutoCalculate),
					zap.Bool("auto_exchange", arg.AutoExchange),
					zap.Bool("auto_check_adult", arg.AutoCheckAdult),
					zap.Bool("save_messages", arg.SaveMessages),
					zap.Bool("enable_coc", arg.EnableCoc),
					zap.Bool("resp_nsfw_msg", arg.RespNsfwMsg),
					zap.Int64("timezone", arg.Timezone),
				),
			)
		}
	}
	_, err := q.exec(ctx, q.createChatCfgStmt, createChatCfg,
		arg.ID,
		arg.WebID,
		arg.AutoCvtBili,
		arg.AutoOcr,
		arg.AutoCalculate,
		arg.AutoExchange,
		arg.AutoCheckAdult,
		arg.SaveMessages,
		arg.EnableCoc,
		arg.RespNsfwMsg,
		arg.Timezone,
	)
	q.logQuery(createChatCfg, "CreateChatCfg", logFields, err, start)
	return err
}

const updateChatStatDaily = `-- name: UpdateChatStatDaily :exec
UPDATE chat_stat_daily
SET message_count        = ?,
    photo_count          = ?,
    video_count          = ?,
    sticker_count        = ?,
    forward_count        = ?,
    mars_count           = ?,
    max_mars_count       = ?,
    racy_count           = ?,
    adult_count          = ?,
    download_video_count = ?,
    download_audio_count = ?,
    dio_add_user_count   = ?,
    dio_ban_user_count   = ?,
    user_msg_stat        = ?,
    msg_count_by_time    = ?,
    msg_id_at_time_start = ?
WHERE chat_id = ?
  AND stat_date = ?
`

type UpdateChatStatDailyParams struct {
	MessageCount       int64          `json:"message_count"`
	PhotoCount         int64          `json:"photo_count"`
	VideoCount         int64          `json:"video_count"`
	StickerCount       int64          `json:"sticker_count"`
	ForwardCount       int64          `json:"forward_count"`
	MarsCount          int64          `json:"mars_count"`
	MaxMarsCount       int64          `json:"max_mars_count"`
	RacyCount          int64          `json:"racy_count"`
	AdultCount         int64          `json:"adult_count"`
	DownloadVideoCount int64          `json:"download_video_count"`
	DownloadAudioCount int64          `json:"download_audio_count"`
	DioAddUserCount    int64          `json:"dio_add_user_count"`
	DioBanUserCount    int64          `json:"dio_ban_user_count"`
	UserMsgStat        UserMsgStatMap `json:"user_msg_stat"`
	MsgCountByTime     TenMinuteStats `json:"msg_count_by_time"`
	MsgIDAtTimeStart   TenMinuteStats `json:"msg_id_at_time_start"`
	ChatID             int64          `json:"chat_id"`
	StatDate           int64          `json:"stat_date"`
}

func (q *Queries) UpdateChatStatDaily(ctx context.Context, arg UpdateChatStatDailyParams) error {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 8)
		start = time.Now()
		if q.LogArgument {
			logFields = append(logFields,
				zap.Dict("fields",
					zap.Int64("message_count", arg.MessageCount),
					zap.Int64("photo_count", arg.PhotoCount),
					zap.Int64("video_count", arg.VideoCount),
					zap.Int64("sticker_count", arg.StickerCount),
					zap.Int64("forward_count", arg.ForwardCount),
					zap.Int64("mars_count", arg.MarsCount),
					zap.Int64("max_mars_count", arg.MaxMarsCount),
					zap.Int64("racy_count", arg.RacyCount),
					zap.Int64("adult_count", arg.AdultCount),
					zap.Int64("download_video_count", arg.DownloadVideoCount),
					zap.Int64("download_audio_count", arg.DownloadAudioCount),
					zap.Int64("dio_add_user_count", arg.DioAddUserCount),
					zap.Int64("dio_ban_user_count", arg.DioBanUserCount),
					zap.Any("user_msg_stat", arg.UserMsgStat),
					zap.Any("msg_count_by_time", arg.MsgCountByTime),
					zap.Any("msg_id_at_time_start", arg.MsgIDAtTimeStart),
					zap.Int64("chat_id", arg.ChatID),
					zap.Int64("stat_date", arg.StatDate),
				),
			)
		}
	}
	_, err := q.exec(ctx, q.updateChatStatDailyStmt, updateChatStatDaily,
		arg.MessageCount,
		arg.PhotoCount,
		arg.VideoCount,
		arg.StickerCount,
		arg.ForwardCount,
		arg.MarsCount,
		arg.MaxMarsCount,
		arg.RacyCount,
		arg.AdultCount,
		arg.DownloadVideoCount,
		arg.DownloadAudioCount,
		arg.DioAddUserCount,
		arg.DioBanUserCount,
		arg.UserMsgStat,
		arg.MsgCountByTime,
		arg.MsgIDAtTimeStart,
		arg.ChatID,
		arg.StatDate,
	)
	q.logQuery(updateChatStatDaily, "UpdateChatStatDaily", logFields, err, start)
	return err
}

const updateChatTopicName = `-- name: UpdateChatTopicName :exec
;

INSERT INTO chat_topics (chat_id, thread_id, name)
VALUES (?, ?, ?)
ON CONFLICT DO UPDATE SET name=excluded.name
`

func (q *Queries) UpdateChatTopicName(ctx context.Context, chatID int64, threadID int64, name string) error {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 8)
		start = time.Now()
		if q.LogArgument {
			logFields = append(logFields,
				zap.Dict("fields",
					zap.Int64("chat_id", chatID),
					zap.Int64("thread_id", threadID),
					zap.String("name", name),
				),
			)
		}
	}
	_, err := q.exec(ctx, q.updateChatTopicNameStmt, updateChatTopicName, chatID, threadID, name)
	q.logQuery(updateChatTopicName, "UpdateChatTopicName", logFields, err, start)
	return err
}

const createChatStatDaily = `-- name: createChatStatDaily :one
INSERT INTO chat_stat_daily (chat_id, stat_date)
VALUES (?, ?)
RETURNING chat_id, stat_date, message_count, photo_count, video_count, sticker_count, forward_count, mars_count, max_mars_count, racy_count, adult_count, download_video_count, download_audio_count, dio_add_user_count, dio_ban_user_count, user_msg_stat, msg_count_by_time, msg_id_at_time_start
`

func (q *Queries) createChatStatDaily(ctx context.Context, chatID int64, statDate int64) (ChatStatDaily, error) {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 8)
		start = time.Now()
		if q.LogArgument {
			logFields = append(logFields,
				zap.Dict("fields",
					zap.Int64("chat_id", chatID),
					zap.Int64("stat_date", statDate),
				),
			)
		}
	}
	row := q.queryRow(ctx, q.createChatStatDailyStmt, createChatStatDaily, chatID, statDate)
	var i ChatStatDaily
	err := row.Scan(
		&i.ChatID,
		&i.StatDate,
		&i.MessageCount,
		&i.PhotoCount,
		&i.VideoCount,
		&i.StickerCount,
		&i.ForwardCount,
		&i.MarsCount,
		&i.MaxMarsCount,
		&i.RacyCount,
		&i.AdultCount,
		&i.DownloadVideoCount,
		&i.DownloadAudioCount,
		&i.DioAddUserCount,
		&i.DioBanUserCount,
		&i.UserMsgStat,
		&i.MsgCountByTime,
		&i.MsgIDAtTimeStart,
	)
	q.logQuery(createChatStatDaily, "createChatStatDaily", logFields, err, start)
	return i, err
}

const createOrUpdateChatAttr = `-- name: createOrUpdateChatAttr :exec
INSERT INTO chat_attr (id, type, title, username, first_name, last_name, is_forum)
VALUES (?, ?, ?, ?, ?, ?, ?)
ON CONFLICT DO UPDATE SET type=excluded.type,
                          title=excluded.title,
                          username=excluded.username,
                          first_name=excluded.first_name,
                          last_name=excluded.last_name,
                          is_forum=excluded.is_forum
`

type createOrUpdateChatAttrParams struct {
	ID        int64          `json:"id"`
	Type      string         `json:"type"`
	Title     sql.NullString `json:"title"`
	Username  sql.NullString `json:"username"`
	FirstName sql.NullString `json:"first_name"`
	LastName  sql.NullString `json:"last_name"`
	IsForum   bool           `json:"is_forum"`
}

func (q *Queries) createOrUpdateChatAttr(ctx context.Context, arg createOrUpdateChatAttrParams) error {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 8)
		start = time.Now()
		if q.LogArgument {
			logFields = append(logFields,
				zap.Dict("fields",
					zap.Int64("id", arg.ID),
					zap.String("type", arg.Type),
					zapNullString("title", arg.Title),
					zapNullString("username", arg.Username),
					zapNullString("first_name", arg.FirstName),
					zapNullString("last_name", arg.LastName),
					zap.Bool("is_forum", arg.IsForum),
				),
			)
		}
	}
	_, err := q.exec(ctx, q.createOrUpdateChatAttrStmt, createOrUpdateChatAttr,
		arg.ID,
		arg.Type,
		arg.Title,
		arg.Username,
		arg.FirstName,
		arg.LastName,
		arg.IsForum,
	)
	q.logQuery(createOrUpdateChatAttr, "createOrUpdateChatAttr", logFields, err, start)
	return err
}

const getChatCfgById = `-- name: getChatCfgById :one

SELECT id, web_id, auto_cvt_bili, auto_ocr, auto_calculate, auto_exchange, auto_check_adult, save_messages, enable_coc, resp_nsfw_msg, timezone
FROM chat_cfg
WHERE id = ?
`

// encoding: utf-8
func (q *Queries) getChatCfgById(ctx context.Context, id int64) (chatCfg, error) {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 8)
		start = time.Now()
		if q.LogArgument {
			logFields = append(logFields,
				zap.Dict("fields",
					zap.Int64("id", id),
				),
			)
		}
	}
	row := q.queryRow(ctx, q.getChatCfgByIdStmt, getChatCfgById, id)
	var i chatCfg
	err := row.Scan(
		&i.ID,
		&i.WebID,
		&i.AutoCvtBili,
		&i.AutoOcr,
		&i.AutoCalculate,
		&i.AutoExchange,
		&i.AutoCheckAdult,
		&i.SaveMessages,
		&i.EnableCoc,
		&i.RespNsfwMsg,
		&i.Timezone,
	)
	q.logQuery(getChatCfgById, "getChatCfgById", logFields, err, start)
	return i, err
}

const getChatIdByWebId = `-- name: getChatIdByWebId :one
SELECT id
FROM chat_cfg
WHERE web_id = ?
`

func (q *Queries) getChatIdByWebId(ctx context.Context, webID sql.NullInt64) (int64, error) {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 8)
		start = time.Now()
		if q.LogArgument {
			logFields = append(logFields,
				zap.Dict("fields",
					zapNullInt64("web_id", webID),
				),
			)
		}
	}
	row := q.queryRow(ctx, q.getChatIdByWebIdStmt, getChatIdByWebId, webID)
	var id int64
	err := row.Scan(&id)
	q.logQuery(getChatIdByWebId, "getChatIdByWebId", logFields, err, start)
	return id, err
}

const getChatStat = `-- name: getChatStat :one
SELECT chat_id, stat_date, message_count, photo_count, video_count, sticker_count, forward_count, mars_count, max_mars_count, racy_count, adult_count, download_video_count, download_audio_count, dio_add_user_count, dio_ban_user_count, user_msg_stat, msg_count_by_time, msg_id_at_time_start
FROM chat_stat_daily
WHERE chat_stat_daily.chat_id = ?
  AND chat_stat_daily.stat_date = ?
`

func (q *Queries) getChatStat(ctx context.Context, chatID int64, statDate int64) (ChatStatDaily, error) {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 8)
		start = time.Now()
		if q.LogArgument {
			logFields = append(logFields,
				zap.Dict("fields",
					zap.Int64("chat_id", chatID),
					zap.Int64("stat_date", statDate),
				),
			)
		}
	}
	row := q.queryRow(ctx, q.getChatStatStmt, getChatStat, chatID, statDate)
	var i ChatStatDaily
	err := row.Scan(
		&i.ChatID,
		&i.StatDate,
		&i.MessageCount,
		&i.PhotoCount,
		&i.VideoCount,
		&i.StickerCount,
		&i.ForwardCount,
		&i.MarsCount,
		&i.MaxMarsCount,
		&i.RacyCount,
		&i.AdultCount,
		&i.DownloadVideoCount,
		&i.DownloadAudioCount,
		&i.DioAddUserCount,
		&i.DioBanUserCount,
		&i.UserMsgStat,
		&i.MsgCountByTime,
		&i.MsgIDAtTimeStart,
	)
	q.logQuery(getChatStat, "getChatStat", logFields, err, start)
	return i, err
}

const updateChatCfg = `-- name: updateChatCfg :exec
UPDATE chat_cfg
SET auto_cvt_bili=?,
    auto_ocr=?,
    auto_calculate=?,
    auto_exchange=?,
    auto_check_adult=?,
    save_messages=?,
    enable_coc=?,
    resp_nsfw_msg=?
WHERE id = ?
`

type updateChatCfgParams struct {
	AutoCvtBili    bool  `json:"auto_cvt_bili"`
	AutoOcr        bool  `json:"auto_ocr"`
	AutoCalculate  bool  `json:"auto_calculate"`
	AutoExchange   bool  `json:"auto_exchange"`
	AutoCheckAdult bool  `json:"auto_check_adult"`
	SaveMessages   bool  `json:"save_messages"`
	EnableCoc      bool  `json:"enable_coc"`
	RespNsfwMsg    bool  `json:"resp_nsfw_msg"`
	ID             int64 `json:"id"`
}

func (q *Queries) updateChatCfg(ctx context.Context, arg updateChatCfgParams) error {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 8)
		start = time.Now()
		if q.LogArgument {
			logFields = append(logFields,
				zap.Dict("fields",
					zap.Bool("auto_cvt_bili", arg.AutoCvtBili),
					zap.Bool("auto_ocr", arg.AutoOcr),
					zap.Bool("auto_calculate", arg.AutoCalculate),
					zap.Bool("auto_exchange", arg.AutoExchange),
					zap.Bool("auto_check_adult", arg.AutoCheckAdult),
					zap.Bool("save_messages", arg.SaveMessages),
					zap.Bool("enable_coc", arg.EnableCoc),
					zap.Bool("resp_nsfw_msg", arg.RespNsfwMsg),
					zap.Int64("id", arg.ID),
				),
			)
		}
	}
	_, err := q.exec(ctx, q.updateChatCfgStmt, updateChatCfg,
		arg.AutoCvtBili,
		arg.AutoOcr,
		arg.AutoCalculate,
		arg.AutoExchange,
		arg.AutoCheckAdult,
		arg.SaveMessages,
		arg.EnableCoc,
		arg.RespNsfwMsg,
		arg.ID,
	)
	q.logQuery(updateChatCfg, "updateChatCfg", logFields, err, start)
	return err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query_pics.sql

package q

import (
	"context"
	"time"

	"go.uber.org/zap"
)

const getNsfwPicByFileUid = `-- name: GetNsfwPicByFileUid :one
SELECT file_uid, file_id, bot_rate, rand_key, user_rate, user_rating_sum, rate_user_count
FROM saved_pics
WHERE file_uid = ?
`

func (q *Queries) GetNsfwPicByFileUid(ctx context.Context, fileUid string) (SavedPic, error) {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 1+5)
		start = time.Now()
		logFields = append(logFields,
			zap.String("file_uid", fileUid),
		)
	}
	row := q.queryRow(ctx, q.getNsfwPicByFileUidStmt, getNsfwPicByFileUid, fileUid)
	var i SavedPic
	err := row.Scan(
		&i.FileUid,
		&i.FileID,
		&i.BotRate,
		&i.RandKey,
		&i.UserRate,
		&i.UserRatingSum,
		&i.RateUserCount,
	)
	q.logQuery(getNsfwPicByFileUid, logFields, err, start)
	return i, err
}

const getPicByRateAndRandKey = `-- name: getPicByRateAndRandKey :one

SELECT file_uid, file_id, bot_rate, rand_key, user_rate, user_rating_sum, rate_user_count
FROM saved_pics
WHERE user_rate = ?
  AND rand_key > ?
LIMIT 1
`

// encoding: utf-8
func (q *Queries) getPicByRateAndRandKey(ctx context.Context, userRate int64, randKey int64) (SavedPic, error) {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 2+5)
		start = time.Now()
		logFields = append(logFields,
			zap.Int64("user_rate", userRate),
			zap.Int64("rand_key", randKey),
		)
	}
	row := q.queryRow(ctx, q.getPicByRateAndRandKeyStmt, getPicByRateAndRandKey, userRate, randKey)
	var i SavedPic
	err := row.Scan(
		&i.FileUid,
		&i.FileID,
		&i.BotRate,
		&i.RandKey,
		&i.UserRate,
		&i.UserRatingSum,
		&i.RateUserCount,
	)
	q.logQuery(getPicByRateAndRandKey, logFields, err, start)
	return i, err
}

const getPicByRateFirst = `-- name: getPicByRateFirst :one
SELECT file_uid, file_id, bot_rate, rand_key, user_rate, user_rating_sum, rate_user_count
FROM saved_pics
WHERE user_rate = ?
ORDER BY rand_key
LIMIT 1
`

func (q *Queries) getPicByRateFirst(ctx context.Context, userRate int64) (SavedPic, error) {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 1+5)
		start = time.Now()
		logFields = append(logFields,
			zap.Int64("user_rate", userRate),
		)
	}
	row := q.queryRow(ctx, q.getPicByRateFirstStmt, getPicByRateFirst, userRate)
	var i SavedPic
	err := row.Scan(
		&i.FileUid,
		&i.FileID,
		&i.BotRate,
		&i.RandKey,
		&i.UserRate,
		&i.UserRatingSum,
		&i.RateUserCount,
	)
	q.logQuery(getPicByRateFirst, logFields, err, start)
	return i, err
}

const getPicRateByUserId = `-- name: getPicRateByUserId :one
SELECT rating
FROM saved_pics_rating
WHERE file_uid = ?
  AND user_id = ?
`

func (q *Queries) getPicRateByUserId(ctx context.Context, fileUid string, userID int64) (int64, error) {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 2+5)
		start = time.Now()
		logFields = append(logFields,
			zap.String("file_uid", fileUid),
			zap.Int64("user_id", userID),
		)
	}
	row := q.queryRow(ctx, q.getPicRateByUserIdStmt, getPicRateByUserId, fileUid, userID)
	var rating int64
	err := row.Scan(&rating)
	q.logQuery(getPicRateByUserId, logFields, err, start)
	return rating, err
}

const getPicRateCounts = `-- name: getPicRateCounts :many
SELECT rate, count
FROM pic_rate_counter
ORDER BY rate
`

func (q *Queries) getPicRateCounts(ctx context.Context) ([]PicRateCounter, error) {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 0+5)
		start = time.Now()
	}
	rows, err := q.query(ctx, q.getPicRateCountsStmt, getPicRateCounts)
	if err != nil {
		q.logQuery(getPicRateCounts, logFields, err, start)
		return nil, err
	}
	defer rows.Close()
	var items []PicRateCounter
	for rows.Next() {
		var i PicRateCounter
		if err = rows.Scan(&i.Rate, &i.Count); err != nil {
			q.logQuery(getPicRateCounts, logFields, err, start)
			return nil, err
		}
		items = append(items, i)
	}
	if err = rows.Close(); err != nil {
		q.logQuery(getPicRateCounts, logFields, err, start)
		return nil, err
	}
	if err = rows.Err(); err != nil {
		q.logQuery(getPicRateCounts, logFields, err, start)
		return nil, err
	}
	q.logQuery(getPicRateCounts, logFields, err, start)
	return items, nil
}

const insertPic = `-- name: insertPic :one
INSERT INTO saved_pics (file_uid, file_id, bot_rate, rand_key, user_rate)
VALUES (?, ?, ?, ?, ?)
ON CONFLICT(file_uid) DO UPDATE SET file_id   = excluded.file_id,
                                    bot_rate  = excluded.bot_rate,
                                    user_rate =
                                        CASE
                                            WHEN excluded.rate_user_count = 0
                                                THEN excluded.bot_rate
                                            ELSE
                                                excluded.user_rate
                                            END
RETURNING file_uid, file_id, bot_rate, rand_key, user_rate, user_rating_sum, rate_user_count
`

type insertPicParams struct {
	FileUid  string `json:"file_uid"`
	FileID   string `json:"file_id"`
	BotRate  int64  `json:"bot_rate"`
	RandKey  int64  `json:"rand_key"`
	UserRate int64  `json:"user_rate"`
}

func (q *Queries) insertPic(ctx context.Context, arg insertPicParams) (SavedPic, error) {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 5+5)
		start = time.Now()
		logFields = append(logFields,
			zap.String("file_uid", arg.FileUid),
			zap.String("file_id", arg.FileID),
			zap.Int64("bot_rate", arg.BotRate),
			zap.Int64("rand_key", arg.RandKey),
			zap.Int64("user_rate", arg.UserRate),
		)
	}
	row := q.queryRow(ctx, q.insertPicStmt, insertPic,
		arg.FileUid,
		arg.FileID,
		arg.BotRate,
		arg.RandKey,
		arg.UserRate,
	)
	var i SavedPic
	err := row.Scan(
		&i.FileUid,
		&i.FileID,
		&i.BotRate,
		&i.RandKey,
		&i.UserRate,
		&i.UserRatingSum,
		&i.RateUserCount,
	)
	q.logQuery(insertPic, logFields, err, start)
	return i, err
}

const ratePic = `-- name: ratePic :exec
INSERT INTO saved_pics_rating (file_uid, user_id, rating)
VALUES (?, ?, ?)
`

func (q *Queries) ratePic(ctx context.Context, fileUid string, userID int64, rating int64) error {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 3+5)
		start = time.Now()
		logFields = append(logFields,
			zap.String("file_uid", fileUid),
			zap.Int64("user_id", userID),
			zap.Int64("rating", rating),
		)
	}
	_, err := q.exec(ctx, q.ratePicStmt, ratePic, fileUid, userID, rating)
	q.logQuery(ratePic, logFields, err, start)
	return err
}

const updatePicRate = `-- name: updatePicRate :exec
UPDATE saved_pics_rating
SET rating=?
WHERE file_uid = ?
  AND user_id = ?
`

func (q *Queries) updatePicRate(ctx context.Context, rating int64, fileUid string, userID int64) error {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 3+5)
		start = time.Now()
		logFields = append(logFields,
			zap.Int64("rating", rating),
			zap.String("file_uid", fileUid),
			zap.Int64("user_id", userID),
		)
	}
	_, err := q.exec(ctx, q.updatePicRateStmt, updatePicRate, rating, fileUid, userID)
	q.logQuery(updatePicRate, logFields, err, start)
	return err
}

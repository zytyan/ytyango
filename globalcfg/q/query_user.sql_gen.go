// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query_user.sql

package q

import (
	"context"
	"database/sql"
	"time"

	"go.uber.org/zap"
)

const getPrprCache = `-- name: GetPrprCache :one
SELECT prpr_file_id
FROM prpr_caches
WHERE profile_photo_uid = ?
`

func (q *Queries) GetPrprCache(ctx context.Context, profilePhotoUid string) (string, error) {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 6)
		start = time.Now()
		logFields = append(logFields,
			zap.Dict("fields",
				zap.String("profile_photo_uid", profilePhotoUid),
			),
		)
	}
	row := q.queryRow(ctx, q.getPrprCacheStmt, getPrprCache, profilePhotoUid)
	var prpr_file_id string
	err := row.Scan(&prpr_file_id)
	q.logQuery("GetPrprCache", logFields, err, start)
	return prpr_file_id, err
}

const setPrprCache = `-- name: SetPrprCache :exec
INSERT INTO prpr_caches (profile_photo_uid, prpr_file_id)
VALUES (?, ?)
`

func (q *Queries) SetPrprCache(ctx context.Context, profilePhotoUid string, prprFileID string) error {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 6)
		start = time.Now()
		logFields = append(logFields,
			zap.Dict("fields",
				zap.String("profile_photo_uid", profilePhotoUid),
				zap.String("prpr_file_id", prprFileID),
			),
		)
	}
	_, err := q.exec(ctx, q.setPrprCacheStmt, setPrprCache, profilePhotoUid, prprFileID)
	q.logQuery("SetPrprCache", logFields, err, start)
	return err
}

const createNewUser = `-- name: createNewUser :one
INSERT INTO users (updated_at, user_id, first_name, last_name, profile_update_at, profile_photo, timezone)
VALUES (?1, ?2, ?3, ?4, ?1, ?5, ?6)
RETURNING id
`

type createNewUserParams struct {
	UpdatedAt    UnixTime       `json:"updated_at"`
	UserID       int64          `json:"user_id"`
	FirstName    string         `json:"first_name"`
	LastName     sql.NullString `json:"last_name"`
	ProfilePhoto sql.NullString `json:"profile_photo"`
	Timezone     int64          `json:"timezone"`
}

func (q *Queries) createNewUser(ctx context.Context, arg createNewUserParams) (int64, error) {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 6)
		start = time.Now()
		logFields = append(logFields,
			zap.Dict("fields",
				arg.UpdatedAt.ZapObject("updated_at"),
				zap.Int64("user_id", arg.UserID),
				zap.String("first_name", arg.FirstName),
				zapNullString("last_name", arg.LastName),
				zapNullString("profile_photo", arg.ProfilePhoto),
				zap.Int64("timezone", arg.Timezone),
			),
		)
	}
	row := q.queryRow(ctx, q.createNewUserStmt, createNewUser,
		arg.UpdatedAt,
		arg.UserID,
		arg.FirstName,
		arg.LastName,
		arg.ProfilePhoto,
		arg.Timezone,
	)
	var id int64
	err := row.Scan(&id)
	q.logQuery("createNewUser", logFields, err, start)
	return id, err
}

const getUserById = `-- name: getUserById :one

SELECT id, updated_at, user_id, first_name, last_name, profile_update_at, profile_photo, timezone
FROM users
WHERE user_id = ?
`

// encoding: utf-8
func (q *Queries) getUserById(ctx context.Context, userID int64) (User, error) {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 6)
		start = time.Now()
		logFields = append(logFields,
			zap.Dict("fields",
				zap.Int64("user_id", userID),
			),
		)
	}
	row := q.queryRow(ctx, q.getUserByIdStmt, getUserById, userID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.UpdatedAt,
		&i.UserID,
		&i.FirstName,
		&i.LastName,
		&i.ProfileUpdateAt,
		&i.ProfilePhoto,
		&i.Timezone,
	)
	q.logQuery("getUserById", logFields, err, start)
	return i, err
}

const updateUserBase = `-- name: updateUserBase :one
UPDATE users
SET updated_at=?2,
    first_name=?3,
    last_name =?4
WHERE user_id = ?1
RETURNING id
`

func (q *Queries) updateUserBase(ctx context.Context, userID int64, updatedAt UnixTime, firstName string, lastName sql.NullString) (int64, error) {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 6)
		start = time.Now()
		logFields = append(logFields,
			zap.Dict("fields",
				zap.Int64("user_id", userID),
				updatedAt.ZapObject("updated_at"),
				zap.String("first_name", firstName),
				zapNullString("last_name", lastName),
			),
		)
	}
	row := q.queryRow(ctx, q.updateUserBaseStmt, updateUserBase,
		userID,
		updatedAt,
		firstName,
		lastName,
	)
	var id int64
	err := row.Scan(&id)
	q.logQuery("updateUserBase", logFields, err, start)
	return id, err
}

const updateUserProfilePhoto = `-- name: updateUserProfilePhoto :exec
UPDATE users
SET profile_update_at = ?2,
    profile_photo     = ?3
WHERE user_id = ?1
`

func (q *Queries) updateUserProfilePhoto(ctx context.Context, userID int64, profileUpdateAt UnixTime, profilePhoto sql.NullString) error {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 6)
		start = time.Now()
		logFields = append(logFields,
			zap.Dict("fields",
				zap.Int64("user_id", userID),
				profileUpdateAt.ZapObject("profile_update_at"),
				zapNullString("profile_photo", profilePhoto),
			),
		)
	}
	_, err := q.exec(ctx, q.updateUserProfilePhotoStmt, updateUserProfilePhoto, userID, profileUpdateAt, profilePhoto)
	q.logQuery("updateUserProfilePhoto", logFields, err, start)
	return err
}

const updateUserTimeZone = `-- name: updateUserTimeZone :exec
INSERT INTO users (user_id, updated_at, timezone)
VALUES (?, ?, ?)
ON CONFLICT DO UPDATE SET updated_at=excluded.updated_at,
                          timezone=excluded.timezone
RETURNING id
`

func (q *Queries) updateUserTimeZone(ctx context.Context, userID int64, updatedAt UnixTime, timezone int64) error {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 6)
		start = time.Now()
		logFields = append(logFields,
			zap.Dict("fields",
				zap.Int64("user_id", userID),
				updatedAt.ZapObject("updated_at"),
				zap.Int64("timezone", timezone),
			),
		)
	}
	_, err := q.exec(ctx, q.updateUserTimeZoneStmt, updateUserTimeZone, userID, updatedAt, timezone)
	q.logQuery("updateUserTimeZone", logFields, err, start)
	return err
}

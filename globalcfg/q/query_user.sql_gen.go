// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query_user.sql

package q

import (
	"context"
	"database/sql"
)

const getPrprCache = `-- name: GetPrprCache :one
SELECT prpr_file_id
FROM prpr_caches
WHERE profile_photo_uid = ?
`

func (q *Queries) GetPrprCache(ctx context.Context, profilePhotoUid string) (string, error) {
	row := q.db.QueryRowContext(ctx, getPrprCache, profilePhotoUid)
	var prpr_file_id string
	err := row.Scan(&prpr_file_id)
	return prpr_file_id, err
}

const setPrprCache = `-- name: SetPrprCache :exec
INSERT INTO prpr_caches (profile_photo_uid, prpr_file_id)
VALUES (?, ?)
`

func (q *Queries) SetPrprCache(ctx context.Context, profilePhotoUid string, prprFileID string) error {
	_, err := q.db.ExecContext(ctx, setPrprCache, profilePhotoUid, prprFileID)
	return err
}

const createNewUser = `-- name: createNewUser :one
INSERT INTO users (updated_at, user_id, first_name, last_name, profile_update_at, profile_photo, timezone)
VALUES (?1, ?2, ?3, ?4, ?1, ?5, ?6)
RETURNING id
`

type createNewUserParams struct {
	UpdatedAt    UnixTime       `json:"updated_at"`
	UserID       int64          `json:"user_id"`
	FirstName    string         `json:"first_name"`
	LastName     sql.NullString `json:"last_name"`
	ProfilePhoto sql.NullString `json:"profile_photo"`
	Timezone     int64          `json:"timezone"`
}

func (q *Queries) createNewUser(ctx context.Context, arg createNewUserParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createNewUser,
		arg.UpdatedAt,
		arg.UserID,
		arg.FirstName,
		arg.LastName,
		arg.ProfilePhoto,
		arg.Timezone,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getUserById = `-- name: getUserById :one

SELECT id, updated_at, user_id, first_name, last_name, profile_update_at, profile_photo, timezone
FROM users
WHERE user_id = ?
`

// encoding: utf-8
func (q *Queries) getUserById(ctx context.Context, userID int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserById, userID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.UpdatedAt,
		&i.UserID,
		&i.FirstName,
		&i.LastName,
		&i.ProfileUpdateAt,
		&i.ProfilePhoto,
		&i.Timezone,
	)
	return i, err
}

const updateUserBase = `-- name: updateUserBase :one
UPDATE users
SET updated_at=?,
    first_name=?,
    last_name =?
WHERE user_id = ?
RETURNING id
`

func (q *Queries) updateUserBase(ctx context.Context, updatedAt UnixTime, firstName string, lastName sql.NullString, userID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, updateUserBase,
		updatedAt,
		firstName,
		lastName,
		userID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateUserProfilePhoto = `-- name: updateUserProfilePhoto :exec
UPDATE users
SET profile_update_at = ?,
    profile_photo     = ?
WHERE user_id = ?
`

func (q *Queries) updateUserProfilePhoto(ctx context.Context, profileUpdateAt UnixTime, profilePhoto sql.NullString, userID int64) error {
	_, err := q.db.ExecContext(ctx, updateUserProfilePhoto, profileUpdateAt, profilePhoto, userID)
	return err
}

const updateUserTimeZone = `-- name: updateUserTimeZone :exec
INSERT INTO users (user_id, updated_at, timezone)
VALUES (?, ?, ?)
ON CONFLICT DO UPDATE SET updated_at=excluded.updated_at,
                          timezone=excluded.timezone
RETURNING id
`

func (q *Queries) updateUserTimeZone(ctx context.Context, userID int64, updatedAt UnixTime, timezone int64) error {
	_, err := q.db.ExecContext(ctx, updateUserTimeZone, userID, updatedAt, timezone)
	return err
}
